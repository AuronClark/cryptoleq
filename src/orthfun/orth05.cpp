// Orthfun research
// New York University at Abu Dhabi, MoMa Lab
// Copyright 2014-2015
// Author: Oleg Mazonka
// File: orth05.cpp

/*
        Test that Leq(a(1+Nkm)) tests parity of m
        a=(N-1)(2k)^-1_N
*/

#include <iostream>

#include "../processor/compiler.h"
#include "../ceal/errex.h"

Unumber calca(Unumber k, Unumber N, Unumber Mod)
{
    Unumber x = k.mul(2, N);
    Unumber k2 = Cell::inv(x, Mod);
    return congruence(k2 * (N - 1), Mod);
}


// this function is not used
// it was used to test that (r^N(1+Nka))^N==(r^N(1+Nkb))^N
Cell power(const ProcessorTS & proc, Cell A, Unumber x)
{
    Cell mp1(0, 0);

    // this must be a code generated by a compiler
    while (x != 0)
    {
        if ( x.getbit(0) )
            //mp1 += A;
            mp1 = proc.BAm1(A.invert(), mp1);

        //A += A;
        A = proc.BAm1(A.invert(), A);
        x >>= 1;
    }

    return mp1;
}

void tmain(int ac, const char * av[])
{
    // Create compiler object
    Compiler comp;

    // initialize
    Unumber p(7), q(11);
    Unumber N(p * q);
    Unumber N2(N * N);
    Unumber k = 5;
    Unumber r = 3;
    comp.init_pqkru(N, p, q, k, r, 1); // u=1
    Unumber rN = r; r.pow(comp.proc.N, comp.proc.N2);

    // Once compiler is initialized, let Cell know about N
    Cell::setN(comp.proc.N);

    for ( int m = 0; m < N; m++ )
    {
        Cell co(m, 0);                          // cell open
        Cell ce = comp.encrypt(m, r);           // cell encrypted
        Cell zo = comp.encrypt(0, r);           // r^N, zero encrypted
        Cell zi = zo.invert();                  // r^-N
        bool le = comp.proc.leq(ce);
        bool lo = comp.proc.leq(co);

        Unumber a = calca(k, N, N);
        Cell ca  = comp.proc.x2ts(a);
        Cell crN = zo;
        Cell am1rN = comp.proc.BAm1(ca, crN);   // a^-1 r^N
        Cell a1Nkm = comp.proc.BAm1(am1rN, ce); // a(1+Nkm)
        bool la = comp.proc.leq(a1Nkm);

        auto ts = a1Nkm.ts();
        auto x = a1Nkm.x();

//        std::cout << m << '\t' << x.str() << '\t' << ts.t.str() << '.' << ts.s.str() << '\n';
        std::cout << m << '\t' << lo << '\t' << le << '\t' << la << '\n';
    }
}



int main(int ac, const char * av[])
try
{
    try { tmain(ac, av); }
    catch (string e) { throw; }
    catch (char const * e) { throw string(e); }
    catch (Err e) { throw e.str(); }
    catch (...) { throw string("unknown"); }
}
catch (string e)
{
    std::cout << "Error: " << e << '\n';
}


